\chapter{Discussion and Conclusion}

% TODO:

\section{Evaluation}

% TODO: Run Beluga v1 and Beluga v1.1 tests on different machines (i9-12900k, i7-3770k, whatever laptop, RAM speeds and disk speeds, deltas in percentage, repeated runs), comment on the runtime performance and memory usage (likely some increased runtime overhead, less memory usage, highlight that the test suites are different from v1 to v1.1 [syntax updates make them technically easier to parse], but also highlight that referencing environments are constructed twice). Present as a table with percentage deltas from v1 to v1.1

Properly defining referencing environments and implementing indexing with respect to them is a step in the right direction.
There are still many implementation challenges ahead in order to fully support structural editing of \Beluga programs and \Harpoon proofs.
Chiefly, proper information flow analysis is required in the later phases of semantic analysis, specifically reconstruction, type-checking and unification, to ascertain whether their stateful operations are always handled soundly.
Indeed, while there is a trailing mechanism for higher-order unification to keep track of meta-variable instantiations (the assignment of a contextual object to a meta-variable), there are routines during \LF reconstruction that ignore this bookkeeping.
This can result in unsound programs when users undo edit actions during interactive proof developments.

Fresh name generation is currently unsound in the implementation of \Beluga.
This has consequences with program synthesis, both for the conversion of \Harpoon proof scripts to \Beluga programs and for error-reporting.
% TODO: Expand, argue we need something akin to Agda's type-checking monad

\section{Future Work}

% TODO: Enable knowledge-based development with proper documentation (language specification for the parser is one step towards that goal)

% TODO:

%The \Harpoon interactive proof environment is too tightly coupled with the rest of the \Beluga system.
%In particular, \Harpoon proof scripts are too verbose, error-prone and redundant.
%Indeed, serializing the meta and computation contexts is unnecessary since they can always be reconstructed, albeit with different names for the bindings.
%Holes in \Beluga programs can represent backward reasoning settings.
%The following snippet describes a proof by backward reasoning, whereby a proof for the subgoal can be constructed by invoking f with unknown arguments x and y.
%
%let x : t1 = ?
%and y : t2 = ?
%in f x y
