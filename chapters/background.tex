\chapter{Background}

% TODO:

\section{\Beluga and \Harpoon}

% TODO: To justify the addition of modules (functioning only as namespaces), use an example of translation between two languages (deBruijn vs. HOAS for instance)
% TODO: To justify the dynamic side of things, consider a query appearing in the middle of a signature. The logic engine is considering too large of a search space by including the constants appearing later in the signature.
% TODO: To additionally justify the dynamic side of things, talk about structured proof editing in a dynamic environment like Harpoon, or Beluga's interactive mode.

% TODO: LFMTP Mid-April, system description of revised parser frontend
% TODO: Drop Harpoon, focus on tension between static and dynamic settings
% TODO: Add the Beluga language specification as an appendix

% What are dependent types? What is LF? What is Twelf? What proofs have been successfully mechanized in Twelf?

% What is contextual modal type theory? Why do we want contextual modal type theory?

% What is Beluga? What proofs have been successfully mechanized in Beluga?

% What is Harpoon? What proofs have been successfully mechanized in Harpoon?

% TODO:

\section{Structured Editing}

% TODO:

\section{Parsing}

% What is parsing?

In compiler design, parsing is the process of converting the textual representation of a program into a hierarchical structure~\cite{aho2007compilers, afroozeh2019practical}.
This structure is typically called a parse tree, since tree data structures correctly represent nested expressions.
A parse forest refers to a collection of parse trees.

% What is ambiguity in parsing?

A program's textual representation is ambiguous if it can be parsed into multiple parse trees.
By way of analogy, a sentence in a natural language is ambiguous if it can be interpreted in multiple valid ways, even though exactly one meaning was meant to be conveyed by it.
Since programming languages are tools for describing computerized systems, it is imperative that every valid written program has exactly one interpretation.
In the strictest of cases, this unicity of interpretation may be enforced at the level of the parser, such that valid programs correspond to exactly one parse tree.
This is typically achieved using rules and syntactic conventions that prevent ambiguous programs from being written in the first place.

Despite that, certain kinds of ambiguities are unavoidable, and oftentimes useful.
Indeed, programming languages often reuse or overload syntactic constructs to reduce the number and complexity of rules that users have to learn in order to read and write programs.
Additional mechanisms then need to be put in place as part of the compiler's implementation to detect ambiguities, and either signal them as errors, or resolve them using conventions.

% What is disambiguation in parsing?

Disambiguation is the process by which a parse forest is filtered down to a single parse tree.
It refers to the procedures used to resolve ambiguities in a parse tree.
Increasing the amount of computation required to disambiguate the textual representation of a program negatively impacts the maintainability and readability of that program.
In increasing level of complexity, we may distinguish three kinds of concrete syntax ambiguities that may arise during parsing:
\begin{itemize}
\item
Operator ambiguities: operators and their operands may be interpreted in different orders.
These are typically resolved by assigning a precedence level, a fixity and an associativity to each operator in the language.
\item
Name-based ambiguities: overloaded identifiers may be resolved to different binding sites depending on where they appear in an expression.
Semantic analysis of the \ac{AST} with respect to a symbol table and lexical convention is usually sufficient in those cases.
\item
Type-based ambiguities: the correct interpretation of an identifier may only be determined once a type has been inferred for it.
Some type information may be provided by a symbol table if the type ascribed to the identifier is known at the declaration site, but in general it is impossible to disambiguate those identifiers before type-checking.
\end{itemize}

% TODO: Figure showcasing typical ambiguities

% What is the typical workflow for designing syntaxes and implementing parsers? What are parser generators? What are their limitations?

Typically, language designers specify the concrete syntax of their language using a context-free grammar.
This has many advantages, including the fact that there is an abundance of battle-tested tools for generating parsers for such languages.
These include \textsc{Yacc}, \textsc{Bison}, \textsc{ocamlyacc}, \textsc{Menhir}, and \textsc{Tree-Sitter}.
Early versions of \Beluga used \textsc{Camlp4} for parsing, but given the complexity of \Beluga's grammar, the errors generated by that implementation were not sufficiently informative.
Hence, \Beluga version \texttt{1.0.0} features a handmade parser using monadic parser combinators.

% What are parser combinators? What are some well-known libraries for parser combinators? What are their limitations?

Monadic parser combinators are higher-order functions for constructing top-down recursive descent parsers~\cite{Burge1975-BURRPT, hutton1996monadic, leijen2001parsec, generalparsercombs}.

% TODO: Define user-extensible grammars, static grammars
% whereby users may define prefix, infix, postfix or even mixfix operators using bound identifiers

% What are some language design considerations?

The design for the concrete syntax of a programming language is intrinsically linked with the algorithm required to parse it.
Languages for specifying logics tend to favour user-extensible grammars over static ones.
This is justified by the need for more concise and expressive ways to convey the meaning of definitions and lemmas.
However, that design choice negatively impacts the implementation of tooling for the language, specifically when it comes to incremental parsing and indexing.

% TODO:

% TODO: Define notation-based ambiguities (precedence, fixity, associativity)
% TODO: Define scope-based ambiguities (identifier classes, mutual recurrences)
% TODO: Define type-based ambiguities (identifier classes, extrinsics, type reconstruction)

% TODO: Define stateless and stateful ambiguity resolutions
