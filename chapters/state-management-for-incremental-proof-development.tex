\chapter{State Management for Incremental Proof Development}

This chapter presents implementation concerns with supporting incremental program development in \Beluga and \Harpoon.
Some technical debt in those systems is highlighted to justify the reimplementation of the indexing phase.
A formalism of identifier resolution in \Beluga is presented to showcase how to efficiently and correctly support de Bruijn indices with multiple indexing contexts.

\section{Introduction}

% What are aspects of state management that are required to support incremental proof development?

% TODO: Provide a somewhat more fine-grained presentation of \Beluga's semantic analysis phase, with an emphasis on explicit state management and talk about transactions (not ACID though, since no fault tolerance)

% TODO:

\section{The Legacy Indexing Phase}

% What is indexing, more precisely?

As outlined in section~\ref{section:beluga-implementation}, the indexing phase of \Beluga's processing pipeline is responsible for converting external syntax trees to corresponding approximate syntax trees.
Specifically, references to constants are replaced with their corresponding symbolic identifiers as defined in the signature reconstruction store, and variables are replaced with their corresponding de Bruijn indices.
This allows for later phases of semantic analysis (such as type-checking and termination analysis) to efficiently look up constant definitions and resolve variables to their binders without having to keep track of the referencing environment.
In the implementation, not all variables are replaced with de Bruijn indices during indexing because binders for implicit parameters are not present in the \ac{AST}; these are introduced during the abstraction phase~\cite{germain2010implementation}.

% What features are required of indexing?

% What was the legacy implementation of indexing? Why did it require re-implementation?

The legacy implementation of indexing was responsible for disambiguating the application of user-defined operators.
This responsibility was moved to its own disambiguation phase, as presented in section~\ref{section:lexing-parsing-disambiguation}.
While this refactoring could have been sufficient in simplifying the legacy implementation, it uncovered significant technical debt in the way identifiers are handled during indexing.

The overarching store illustrated in figure~\ref{figure:legacy-beluga-processing-pipeline} records the constant declarations encountered during signature reconstruction.
These declarations are arranged in tables, with each kind of constant having its own table.
Variables, on the other hand, are arranged in separate association lists.
This means that there is no overlap between identifiers belonging to different kinds since they are not looked up in the same table or association list, which effectively creates distinct namespaces for them.
For instance, \LF type-level and term-level constants have their own declaration table, separate from computation-level type constants and constructors.
This design aimed at ensuring that variables and constants originating from the \LF, meta or computation levels do not end up appearing in terms of a different level~\cite{germain2010implementation}.
Unfortunately, without having a unique table representing an entire referencing environment, name resolution in the presence of shadowing proved obtuse and lead to unexpected results when coupled with overloading of identifiers.
Indeed, when a constant identifier was resolved during indexing, the declaration tables in the store had to be looked up in a pre-defined order.
Consequently, during identifier lookups, parts of the referencing environment would not exist depending on the expected kind of variable or constant encountered in the \ac{AST}.
As an example, it was impossible for a computation-level coinductive type constant to shadow an inductive one simply because the table for declarations of the former kind was always looked up after the table for declarations of the latter kind.
Counterintuitively, one could introduce a meta-level variable with an \verb|mlam|-binder and a computation-level variable with an \verb|fn|-binder, both using the same identifier, and be able to use both meanings for that identifier in meta-level and computation-level expressions respectively.

The aforementioned incongruities in name resolution motivate the reimplementation of the indexing phase to use one unified namespace while ensuring that identifiers with different levels cannot be mixed.
Without having types available at this stage of processing, the accidental feature of identifier overloading had to be discarded.

%\section{Signature Reconstruction Pipeline}

% TODO: Provide a more fine-grained presentation of \Beluga's semantic analysis phase, with an emphasis on explicit state management and ACID transactions

\section{Unified Indexing}\label{section:indexing}

% An important implementation challenge in re-implementing this phase of the pipeline was ensuring that the outcome of indexing is the same as it was with the legacy architecture.

The unified indexing phase is designed as a single sequential traversal of the external \ac{AST} to map it to the approximate \ac{AST}, using the referencing environment as visitor state.
As \ac{AST} nodes are traversed, the referencing environment is updated by adding or removing identifiers in scope so that the resolution of identifiers is consistent with the language's specification.
This presents the challenge of cohesively handling namespaces for modules, patterns for computation-level pattern-matching expressions, and the computation of de Bruijn indices across distinct identifier worlds~\cite{ferreira2012compiler}.
This includes name resolution under pattern lambda-expressions in contextual \LF patterns, and distinguishing between pattern variables and bound identifiers.
All the while, indexing has to feature backtracking mechanisms to support incremental proof development in \Harpoon sessions.
In the disambiguation phase, where a similar mapping occurs from the parser \ac{AST} to the external \ac{AST}, the visitor state has to additionally keep track of user-defined notations.

We define a referencing environment for \Beluga as illustrated in figure~\ref{figure:referencing-environment-definition} as a stack of scopes.
In the implementation, a scope is a tree of bindings, which is defined as a dictionary of stacks where entries are may optionally point to a subtree of bindings.
The tree structure allows bindings to uniformly support namespacing.
On the other hand, the stack structure of each binding allows for identifier shadowing, and the efficient addition and removal of bindings.
A lookup for the definition bound to a qualified identifier in a referencing environment searches for the topmost scope whose tree of bindings contains the leading identifier in the qualified identifier.
Once that scope is found, then the tree of bindings is traversed following the list of identifiers that form the qualified identifier.

% TODO: Introduce modules and patterns in two separate paragraphs

Since \Beluga supports defining constants in modules and pattern-matching, we distinguish between three kinds of scopes which operate differently in the way bindings are added to them:
\begin{enumerate}
\item
\textit{Plain scopes}: this kind of scope does not have additional mechanisms.
Plain scopes are suitable for introducing multiple identifiers in such a way that they can be efficiently removed by discarding the scope entirely.
\item
\textit{Module scopes}: constants added to this kind of scope are either private or public.
Private constant declarations refer to constants that are not exported from the module when it is opened.
This ensures that constants and notations imported from external modules are not re-exported when the module is opened elsewhere.
Public constant declarations on the other hand are brought back in scope when the module is opened.
\item
\textit{Pattern scopes}: variables added to this kind of scope are inner pattern-bound or pattern variables.
Inner pattern-bound variables are introduced by binders in the pattern.
Pattern variables on the other hand are free variables in the pattern, which become bound variables in the body of the match case.
Because of \Beluga's feature of automatic reconstruction of meta-level abstractions, free meta-variables in patterns are both inner pattern-bound and pattern variables.
\end{enumerate}

% TODO:

% TODO: Present the data structures for name resolution in the implementation (binding tree, binding domains, scope stack, context sizes for de Bruijn indices computations)

% TODO: Purpot that we can have a unification algorithm in a named setting if we compute de Bruijn indices on the fly

% TODO: Purpot that this implementation is scalable to multi-modal logics and multi-level contextual modal logic

% TODO: Present a model for mechanizing name resolution semantic analysis, using an association list, context sizes and binding sorts (bindings tagged with their domains)

\newcommand{\private}[1]{#1_\downarrow}
\newcommand{\public}[1]{#1_\uparrow}
\newcommand{\Private}[1]{#1_\Downarrow}
\newcommand{\Public}[1]{#1_\Uparrow}
\newcommand{\Env}{\Xi}
\newcommand{\Scope}{\mathbb{S}}
\newcommand{\Module}{\mathbb{M}}
\newcommand{\Pattern}{\mathbb{P}}
\newcommand{\Entry}{\mathbb{E}}
\newcommand{\Var}{\mathbb{V}}
\newcommand{\Constant}{\mathbb{C}}

\begin{figure}[htb]
\centering
\begin{tabular}{lrcl}
Referencing environment & $\Env$ & $\Coloneqq$ & $\cdot \mid \Env; \Scope \mid \Env; \Module \mid \Env; \Pattern$\\
Plain scope & $\Scope$ & $\Coloneqq$ & $\cdot \mid \Scope, x : \Var$\\
Module scope & $\Module$ & $\Coloneqq$ & $\cdot \mid \Module, \Private{x} : \Constant \mid \Module, \Public{x} : \Constant$\\
Pattern scope & $\Pattern$ & $\Coloneqq$ & $\cdot \mid \Pattern, \private{x} : \Var \mid \Pattern, \public{x} : \Var$\\
%Entry & $\Entry$ & $\Coloneqq$ & $ \Constant \mid \Var $\\
Constant & $ \Constant $ & $ \Coloneqq $ & $\mathsf{LF}_{\mathsf{type\ const}} \mid \mathsf{LF}_{\mathsf{term\ const}} \mid \mathsf{Module}\left(\overrightarrow{\Public{x} : \Constant}\right) \mid \cdots$\\
Variable & $ \Var $ & $ \Coloneqq $ & $ \mathsf{LF}_{\mathsf{term}} \mid \mathsf{Comp}_{\mathsf{term}} \mid \mathsf{Ctx} \mid \cdots $
\end{tabular}
\caption[Definition of referencing environments for indexing \Beluga signatures]{%
Definition of the structure of referencing environments for indexing \Beluga signatures.
Some variants for constants and variables have been omitted for brevity.
Identifiers denoted as $\Private{x}$ and $\Public{x}$ in a module scope denote private declarations and public declarations respectively.
Likewise, identifiers denoted as $\private{x}$ and $\public{x}$ in a pattern scope denote inner-pattern variables and pattern variables respectively.
}
\label{figure:referencing-environment-definition}
\end{figure}

Given \Beluga's design for signature-level declaration of constants, the indexing phase can be parallelized.
This is because the body of a signature-level declaration is guaranteed not to export non-constant identifiers, which means that most of the \ac{AST} can be disregarded when we need to construct the referencing environment right before a signature-level declaration.
As such, the declarations in a signature can first be traversed to preallocate symbolic identifiers for toplevel constants and store them in a queue.
Concurrent threads can then be assigned non-overlapping ranges of declarations to process, and the initial referencing environment for each can be constructed using only that queue.

\newcommand{\Fail}{\lightning}
\newcommand{\Lookup}[2]{\operatorname{lookup}\left[#1\right]\left(#2\right)}
\newcommand{\Domain}{\operatorname{domain}}
% TODO: Define \Env \setminus \Var(\Env) \mid \Env', punch holes in the environment for variables
\begin{equation*}
\begin{aligned}
\Domain(\cdot) &= \{\}\\
\Domain(\Scope, x : \Var) &= \{x\} \cup \Domain(\Scope)\\
\Domain(\Module, \Private{x} : \Var) &= \{x\} \cup \Domain(\Module)\\
\Domain(\Module, \Public{x} : \Var) &= \{x\} \cup \Domain(\Module)\\
\Domain(\Pattern, \private{x} : \Var) &= \{x\} \cup \Domain(\Pattern)\\
\Domain(\Pattern, \public{x} : \Var) &= \Domain(\Pattern)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x}{\cdot} &= \Fail\\
\Lookup{x}{\Env; \cdot} &= \Lookup{x}{\Env}\\
\Lookup{x}{\Env; \Scope, x : \Var} &= (x : \Var)\\
\Lookup{x}{\Env; \Scope, y : \Var} &= \Lookup{x}{\Env; \Scope} & x \neq y\\
\Lookup{x}{\Env; \Module, \Private{x} : \Constant} &= (x : \Constant)\\
\Lookup{x}{\Env; \Module, \Private{y} : \Constant} &= \Lookup{x}{\Env; \Module} & x \neq y\\
\Lookup{x}{\Env; \Module, \Public{x} : \Constant} &= (x : \Constant)\\
\Lookup{x}{\Env; \Module, \Public{y} : \Constant} &= \Lookup{x}{\Env; \Module} & x \neq y\\
\Lookup{x}{\Env; \Pattern, \private{x} : \Var} &= (x : \Var)\\
\Lookup{x}{\Env; \Pattern, \private{y} : \Var} &= \Lookup{x}{\Env \setminus \Var(\Env); \Pattern} & x \neq y\\
\Lookup{x}{\overrightarrow{\cdot}} &= \Fail\\
\Lookup{x}{\overrightarrow{\Public{y} : \Constant}, x : \Constant} &= (x : \Constant)\\
\Lookup{x}{\overrightarrow{\Public{x} : \Constant}, y : \Constant} &= \Lookup{x}{\overrightarrow{\Public{x} : \Constant}} & x \neq y
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Scope} &= \Lookup{x_1.x_2.\cdots.x_n}{\Env} & x_1 \notin \Domain(\Scope)\\
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Scope} &= \Fail & x_1 \in \Domain(\Scope)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Module, x_1 : \mathsf{Module}\left(\overrightarrow{\Public{x}:\Constant}\right)} &= \Lookup{x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}}\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\cdot}} &= \Fail\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}, y : \Constant} &= \Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}} & x_1 \neq y\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{y}:\Constant}, x_1: \mathsf{Module}\left(\overrightarrow{\Public{x}:\Constant}\right)} &= \Lookup{x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}}
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Pattern} &= \Lookup{x_1.x_2.\cdots.x_n}{\Env} & x_1 \notin \Domain(\Pattern)\\
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Pattern} &= \Fail & x_1 \in \Domain(\Scope)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Psi(\cdot) &= ()\\
\Psi(\Env; \cdot_\Scope) &= \Psi(\Env)\\
\Psi(\Env; \Scope, x : \mathsf{LF}_{\mathsf{term}}) &= \Psi(\Env; \Scope) \oplus (x : \mathsf{LF}_{\mathsf{term}})\\
\Psi(\Env; \Scope, x : \Var) &= \Psi(\Env; \Scope) & \Var \neq \mathsf{LF}_{\mathsf{term}}\\
\Psi(\Env; \cdot_\Module) &= \Psi(\Env)\\
\Psi(\Env; \Module) &= \Psi(\Env)\\
\Psi(\Env; \cdot_\Pattern) &= ()\\
\Psi(\Env; \Pattern, \private{x} : \mathsf{LF}_{\mathsf{term}}) &= \Psi(\Pattern) \oplus (x : \mathsf{LF}_{\mathsf{term}})\\
\Psi(\Env; \Pattern, \private{x} : \Var) &= \Psi(\Pattern) & \Var \neq \mathsf{LF}_{\mathsf{term}}
\end{aligned}
\end{equation*}

% TODO: Wrong formalism, use equality for lookup(\Xi, \P)...

%\begin{equation}
%(\Scope, x : \Var)(x) = (x : \Var)
%\end{equation}
%
%\begin{equation}
%\infer{(x : \Var) \in (\Scope, x : \Var)}{}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Scope, y : \Entry'}{x : \Var \in \Scope & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Module, \Private{x} : \Constant}{}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Module, \Public{x} : \Constant}{}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Module, \Private{y} : \Constant'}{x : \Constant \in \Module & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Module, \Public{y} : \Constant'}{x : \Constant \in \Module & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Pattern, \private{x} : \Var}{}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Pattern, \private{y} : \Var}{x : \Var \in \Pattern & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Pattern, \public{y} : \Var}{x : \Var \in \Pattern & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Env; \Scope}{x : \Var \in \Scope}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Entry \in \Env; \Scope}{x \notin \Scope & x : \Entry \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Env; \Module}{x : \Constant \in \Module}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Entry \in \Env; \Module}{x \notin \Module & x : \Entry \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Var \in \Env; \Pattern}{x : \Var \in \Pattern}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \Env; \Pattern}{x \notin \Pattern & x : \Constant \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x_1 . x_2 . \cdots . x_n : \Constant \in \Env; \Scope}{x_1 \notin \Scope & x_1 . x_2 . \cdots . x_n : \Constant \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x_1 . x_2 . \cdots . x_n : \Constant \in \Env; \Module}{x_1 \notin \Module & x_1 . x_2 . \cdots . x_n : \Constant \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x_1 . x_2 . \cdots . x_n : \Constant \in \Env; \Pattern}{x_1 \notin \Pattern & x_1 . x_2 . \cdots . x_n : \Constant \in \Env}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \left(\overrightarrow{\Public{x}' : \Constant'}, x_\Uparrow : \Constant\right)}{}
%\end{equation}
%
%\begin{equation}
%\infer{x : \Constant \in \left(\overrightarrow{\Public{x}' : \Constant'}, \Public{y} : \Constant\right)}{x : \Constant \in \overrightarrow{\Public{x}' : \Constant'} & x \neq y}
%\end{equation}
%
%\begin{equation}
%\infer{x_1 . x_2 . \cdots . x_n : \Constant \in \overrightarrow{\Public{x} : \Constant'}}{x_1 : \mathsf{Module}\left(\overrightarrow{\Public{x}' : \Constant''}\right) \in \overrightarrow{\Public{x} : \Constant'} & x_2 . \cdots . x_n : \Constant \in \overrightarrow{\Public{x}' : \Constant''}}
%\end{equation}
%
%\begin{equation}
%\infer{x_1 . x_2 . \cdots . x_n : \Constant \in \Env; \Module, x_1 : \mathsf{Module}\left(\overrightarrow{\Public{x} : \Constant'}\right)}{x_2 . \cdots . x_n : \Constant \in \overrightarrow{\Public{x} : \Constant'}}
%\end{equation}

%\section{Pretty-Printing}
%
%% What is pretty-printing?
%
%Pretty-printing is the process that transforms an \ac{AST} back into its textual representation.
%This feature of programming languages is often used to implement automated formatting software as part of tooling.
%As it pertains to \Beluga and \Harpoon, pretty-printing is used by the developers during debugging to trace the execution of signature reconstruction, and it is used by the user when programmatically generated programs need to be displayed in interactive sessions.
%
%% What are considerations to make when it comes to implementing pretty-printing?
%
%Depending on the lexical conventions used during parsing, a pretty-printed \ac{AST} may not exactly correspond to its initial textual representation.
%Indeed, the program's layout may change, inline comments may be printed in different locations, and extraneous parentheses may be removed.
%
%Handling of the printed program's layout can be implemented using the algorithm described in~\cite{oppen1980prettyprinting}, whereby layout boxes and break hints are output during printing, and then actual break point locations are later computed to satisfy the layout and margin constraints.
%The \OCaml standard library provides an implementation of this algorithm in its \mintinline{ocaml}|Format| module~\cite{leroy2022ocaml}.
%
%The usual lexical convention is to treat comments as white spaces.
%This simplifies the \ac{AST} representation of programs by effectively discarding all the comments.
%However, during pretty-printing for formatting a program, those comments need to be restored.
%A separate interval map data structure may be created during the lexing stage in order to keep track of inline comments with respect to their location.
%Provided the program \ac{AST} is annotated with locations, then it is possible during printing to determine where a comment should be spliced in.
%
%Handling of parentheses is less straightforward.
%Indeed, a node in the program's \ac{AST} needs to be mapped back to the parser production that created it in order to determine its precedence.
%Additionally, the associativity of operators appearing at the same precedence level must be taken into consideration to avoid producing ambiguous textual representations.
%
%% How can pretty-printing be implemented in Beluga?
%
%Pretty-printing of \Beluga's internal syntax requires the generation of fresh identifiers to replace de Bruijn indices.
%Hence, not only is printing stateful, it also needs an auxiliary data structure containing the set of identifiers that are used by sub-expressions.
%Indeed, one needs to know what identifiers are used in the term under a $\lambda$-abstraction before generating an identifier for the $\lambda$-abstraction's parameter.
%Otherwise, the generated identifier may shadow a referenced identifier.
%The data structure to support this feature may be implemented in many ways, but in general this problem reduces to annotating a tree with additional data~\cite{najd2016trees}:
%
%\begin{enumerate}
%\item
%Parallel data types equipped with extra fields may be defined for each kind of node in the \ac{AST}.
%During pretty-printing, the \ac{AST} and this auxiliary data structure then must be traversed at the same time.
%\item
%Each node in the \ac{AST} may be equipped with a unique identifier to be used as key in a map data structure.
%Then, lookups can be made on that map during printing to fetch the necessary data.
%\item
%The auxiliary data may be embedded type-safely into the \ac{AST} using recursion schemes.
%\end{enumerate}
%
%The approach with the least impact on the rest of the implementation is to construct printing closures using a top-down traversal of the \ac{AST}.
%At any given node, this traversal recursively computes the set of used de Bruijn offsets, and then constructs a closure accepting the referencing environment to determine the identifiers corresponding to those offsets.

% TODO:

%\section{Testing}

% TODO: Present data-driven testing
% TODO: Present the micro-tests and benefits of having an unambiguous AST to inspect
% TODO: Present the parser test using pretty-printing

%\section{Related Work}
