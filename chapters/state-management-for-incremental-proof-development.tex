\chapter{State Management for Incremental Proof Development}

This chapter presents implementation concerns with supporting incremental program development in \Beluga and \Harpoon.
Some technical debt in those systems is highlighted to justify the reimplementation of the indexing phase.
A formalism of identifier resolution in \Beluga is presented to showcase how to efficiently and correctly support de Bruijn indices with multiple indexing contexts.

\section{Introduction}

% What are the features desired for Harpoon and Beluga?
% Why do those features help in incremental proof development?

% How do other systems supporting interactive proof sessions handle state management?

% TODO: Does Abella support incremental development?
% TODO: See if Agda breaks with splicing
% TODO: See if Coq has incremental development as well

% What are aspects of state management that are required to support incremental proof development?
% In what way are state management and exception handling closely linked with respect to interactive proof sessions?

% TODO:

\section{The Legacy Indexing Phase}

% What is indexing, more precisely?

As outlined in section~\ref{section:beluga-implementation}, the indexing phase of \Beluga's processing pipeline is responsible for converting external syntax trees to corresponding approximate syntax trees.
Specifically, references to constants are replaced with their corresponding symbolic identifiers as defined in the signature reconstruction store, and variables are replaced with their corresponding de Bruijn indices.
This allows for later phases of semantic analysis (such as type-checking and termination analysis) to efficiently look up constant definitions and resolve variables to their binders without having to nominally keep track of the referencing environment.
In the implementation, not all variables are replaced with de Bruijn indices during indexing because binders for implicit parameters are not present in the \ac{AST}; these are introduced during the abstraction phase~\cite{germain2010implementation}.

% What features are required of indexing?

% What was the legacy implementation of indexing? Why did it require re-implementation?

The legacy implementation of indexing was responsible for disambiguating the application of user-defined operators since it kept track of constants as they are introduced in \Beluga signatures.
This disambiguation leveraged Dijkstra's shunting-yard algorithm as opposed to the recursive descent parsing algorithm presented in section~\ref{section:parsing-user-defined-operators}.
This responsibility has been moved to its own disambiguation phase, as presented in section~\ref{section:lexing-parsing-disambiguation}.
While this refactoring could have been sufficient in simplifying the legacy implementation, it uncovered significant technical debt and issues having to do with the way identifiers are handled during indexing.

The overarching store illustrated in figure~\ref{figure:legacy-beluga-processing-pipeline} records the constant declarations encountered during signature reconstruction.
These declarations are arranged in tables, with each kind of constant having its own table.
Variables, on the other hand, are arranged in separate association lists.
This means that there is no overlap between identifiers belonging to different kinds since they are not looked up in the same table or association list, which effectively creates distinct namespaces for them.
For instance, \LF type-level and term-level constants have their own declaration table, separate from computation-level type constants and constructors.
This design aimed at ensuring that variables and constants originating from the \LF, meta or computation levels do not end up appearing in terms of a different level~\cite{germain2010implementation}.
Unfortunately, without having a unique table representing an entire referencing environment, name resolution in the presence of shadowing proved obtuse and lead to unexpected results when coupled with overloading of identifiers.
Indeed, when a constant identifier was resolved during indexing, the declaration tables in the store had to be looked up in a pre-defined order.
That is, identifiers would not be looked up with respect to the global order in which they are declared, but rather first with respect to the order of identifier kinds, and then the declaration order.
Consequently, during identifier lookups, parts of the referencing environment would not exist depending on the expected kind of variable or constant encountered in the \ac{AST}.
As an example, it was impossible for a computation-level coinductive type constant to shadow an inductive one simply because the table for declarations of the former kind was always looked up after the table for declarations of the latter kind.
Counterintuitively, one could introduce a meta-level variable with an \verb|mlam|-binder and a computation-level variable with an \verb|fn|-binder, both using the same identifier, and be able to use both meanings for that identifier in meta-level and computation-level expressions respectively.
This overloading would not translate well in proofs on paper since an identifier could be used to refer to two distinct objects at once.

Additionally, the legacy indexing algorithm is tightly coupled and implicitly dependent on the store of constants depicted in figure~\ref{figure:legacy-beluga-processing-pipeline}.
This means that external mutations to that store affect the output of functions responsible for identifier resolution.
As outlined in section~\ref{section:intro-state-management}, this design is only suitable for a single pass through the processing pipeline since the store's state is consistent with how the \ac{AST} is traversed.
However, indexing was explicitly parameterized with respect to a store of variables to allow \acp{REPL} instantiated at the very end of a \Beluga signature to be consistent with identifier resolution during signature reconstruction.
Incremental proof development sessions instantiated on holes anywhere else but the end of a \Beluga signature could potentially result in invalid programs.
Indeed, since the store is stuck at its state at the very end of the \Beluga signature, constants declared later would be incorrectly brought into scope, even shadowing the actual constants required for the proof development.
In order to ensure soundness of incremental proof development with multiple holes, it became necessary for indexing to be implemented with an explicit parameterization over the entire referencing environment as opposed to just the stores of variables.

The aforementioned incongruities in name resolution and tight coupling with the signature reconstruction store motivate the reimplementation of the indexing phase to use one unified namespace while ensuring that identifiers with different levels cannot be mixed.
Without having types available at this stage of processing, the accidental feature of identifier overloading had to be discarded.

\section{Unified Indexing}\label{section:indexing}

% TODO: What is unified indexing?

% An important implementation challenge in re-implementing this phase of the pipeline was ensuring that the outcome of indexing is the same as it was with the legacy architecture.

A fully qualified identifier is a list of plain identifiers separated by dots denoting projection.
A referencing environment in \Beluga is the data structure that holds the associations from fully qualified identifiers to definitions in a signature.
The unified indexing phase is designed as a single sequential traversal of the external \ac{AST} to map it to the approximate \ac{AST}, using the referencing environment as visitor state.
As \ac{AST} nodes are traversed, the referencing environment is updated by adding or removing identifiers in scope so that the resolution of identifiers is consistent with the language's specification.
This presents the challenge of cohesively handling namespaces for modules, patterns for computation-level pattern-matching expressions, and the computation of de Bruijn indices across distinct identifier worlds~\cite{ferreira2012compiler}.
This includes name resolution under pattern lambda-expressions in contextual \LF patterns, and distinguishing between pattern variables and bound identifiers.
All the while, indexing has to feature backtracking mechanisms to support incremental proof development in \Harpoon sessions.
In the disambiguation phase, where a similar mapping occurs from the parser \ac{AST} to the external \ac{AST}, the visitor state has to additionally keep track of user-defined notations.

Since \Beluga supports defining constants in modules and pattern-matching, we distinguish between three kinds of scopes which operate differently in the way bindings are added to them:
\begin{enumerate}
\item
\textit{Plain scopes}: this kind of scope does not have additional mechanisms.
Plain scopes are suitable for introducing multiple identifiers in such a way that they can be efficiently removed by discarding the scope entirely.
\item
\textit{Module scopes}: constants added to this kind of scope are either private or public.
Private constant declarations refer to constants that are not exported from the module when it is opened.
This ensures that constants and notations imported from external modules are not re-exported when the module is opened elsewhere.
Public constant declarations on the other hand are brought back in scope when the module is opened.
\item
\textit{Pattern scopes}: variables added to this kind of scope are inner pattern-bound or pattern variables.
Inner pattern-bound variables are introduced by binders in the pattern.
Pattern variables on the other hand are free variables in the pattern, which become bound variables in the body of the match case.
Because of automatic reconstruction of meta-level abstractions in \Beluga, free meta-variables in patterns are both inner pattern-bound and pattern variables.
\end{enumerate}

The next subsections present two different ways of realising a referencing environment for \Beluga that supports unified lexing.
The first definition is suitable for mechanized proofs, whereas the second is used in the implementation as it is computationally more efficient.
Both are presented here for the sake of completeness.

\subsection{Formalising Unified Indexing}

In the theory, a referencing environment is an association list with delimiters for scopes.
Each entry in the list may itself point to a separate association list to support namespacing.
Shadowing is also supported since those association lists can function as stacks.
Lookups in this environment then proceed by simultaneously traversing the fully qualified identifier and the association list, much like in the previous lookup procedure.

% TODO: Illustrate this structure

\begin{figure}[htb]
\begin{Verbatim}[commandchars=\\\{\}, baselinestretch=1, numbers=left]
\verbbf{module} Nat = \verbbf{struct}
  \verbbf{LF} nat : \verbbf{type} =
  | z : nat
  | s : nat \makebox[1em]{→} nat;
  \verbbf{rec} plus : [ \makebox[1em]{⊢} nat] \makebox[1em]{→} [ \makebox[1em]{⊢} nat] \makebox[1em]{→} [ \makebox[1em]{⊢} nat] = \verbhole{?h1};
\verbbf{end}
\verbbf{rec} f : [ \makebox[1em]{⊢} Nat.nat] \makebox[1em]{→} [ \makebox[1em]{⊢} Nat.nat] = \verbhole{?h2};
\verbprag{--open Nat.}
\verbbf{rec} g : [ \makebox[1em]{⊢} nat] \makebox[1em]{→} [ \makebox[1em]{⊢} nat] = \verbhole{?h3};
\end{Verbatim}
\caption[]{%
% TODO:
}
\label{figure:referencing-environment-example}
% TODO: Subfigures with the referencing environment at h1, h2, h3
\end{figure}

% TODO: Introduce modules and patterns in two separate paragraphs

% TODO:

% TODO: Present a model for mechanizing name resolution semantic analysis, using an association list, context sizes and binding sorts (bindings tagged with their domains)

\newcommand{\private}[1]{#1_\downarrow}
\newcommand{\public}[1]{#1_\uparrow}
\newcommand{\Private}[1]{#1_\Downarrow}
\newcommand{\Public}[1]{#1_\Uparrow}
\newcommand{\Env}{\Xi}
\newcommand{\Scope}{\mathbb{S}}
\newcommand{\Module}{\mathbb{M}}
\newcommand{\Pattern}{\mathbb{P}}
\newcommand{\Entry}{\mathbb{E}}
\newcommand{\Var}{\mathbb{V}}
\newcommand{\Constant}{\mathbb{C}}

\begin{figure}[htb]
\centering
\begin{tabular}{lrcl}
Referencing environment & $\Env$ & $\Coloneqq$ & $\cdot \mid \Env; \Scope \mid \Env; \Module \mid \Env; \Pattern$\\
Plain scope & $\Scope$ & $\Coloneqq$ & $\cdot \mid \Scope, x : \Var$\\
Module scope & $\Module$ & $\Coloneqq$ & $\cdot \mid \Module, \Private{x} : \Constant \mid \Module, \Public{x} : \Constant$\\
Pattern scope & $\Pattern$ & $\Coloneqq$ & $\cdot \mid \Pattern, \private{x} : \Var \mid \Pattern, \public{x} : \Var$\\
%Entry & $\Entry$ & $\Coloneqq$ & $ \Constant \mid \Var $\\
Constant & $ \Constant $ & $ \Coloneqq $ & $\mathsf{LF}_{\mathsf{type\ const}} \mid \mathsf{LF}_{\mathsf{term\ const}} \mid \mathsf{Module}\left(\overrightarrow{\Public{x} : \Constant}\right) \mid \cdots$\\
Variable & $ \Var $ & $ \Coloneqq $ & $ \mathsf{LF}_{\mathsf{term}} \mid \mathsf{Comp}_{\mathsf{term}} \mid \mathsf{Ctx} \mid \cdots $
\end{tabular}
\caption[Definition of referencing environments for indexing \Beluga signatures]{%
Definition of the structure of referencing environments for indexing \Beluga signatures.
Some variants for constants and variables have been omitted for brevity.
Identifiers denoted as $\Private{x}$ and $\Public{x}$ in a module scope denote private declarations and public declarations respectively.
Likewise, identifiers denoted as $\private{x}$ and $\public{x}$ in a pattern scope denote inner-pattern variables and pattern variables respectively.
}
\label{figure:referencing-environment-definition}
\end{figure}

\newcommand{\Fail}{\lightning}
\newcommand{\Lookup}[2]{\operatorname{lookup}\left[#1\right]\left(#2\right)}
\newcommand{\Domain}{\operatorname{domain}}
% TODO: Define \Env \setminus \Var(\Env) \mid \Env', punch holes in the environment for variables
\begin{equation*}
\begin{aligned}
\Domain(\cdot) &= \{\}\\
\Domain(\Scope, x : \Var) &= \{x\} \cup \Domain(\Scope)\\
\Domain(\Module, \Private{x} : \Var) &= \{x\} \cup \Domain(\Module)\\
\Domain(\Module, \Public{x} : \Var) &= \{x\} \cup \Domain(\Module)\\
\Domain(\Pattern, \private{x} : \Var) &= \{x\} \cup \Domain(\Pattern)\\
\Domain(\Pattern, \public{x} : \Var) &= \Domain(\Pattern)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x}{\cdot} &= \Fail\\
\Lookup{x}{\Env; \cdot} &= \Lookup{x}{\Env}\\
\Lookup{x}{\Env; \Scope, x : \Var} &= (x : \Var)\\
\Lookup{x}{\Env; \Scope, y : \Var} &= \Lookup{x}{\Env; \Scope} & x \neq y\\
\Lookup{x}{\Env; \Module, \Private{x} : \Constant} &= (x : \Constant)\\
\Lookup{x}{\Env; \Module, \Private{y} : \Constant} &= \Lookup{x}{\Env; \Module} & x \neq y\\
\Lookup{x}{\Env; \Module, \Public{x} : \Constant} &= (x : \Constant)\\
\Lookup{x}{\Env; \Module, \Public{y} : \Constant} &= \Lookup{x}{\Env; \Module} & x \neq y\\
\Lookup{x}{\Env; \Pattern, \private{x} : \Var} &= (x : \Var)\\
\Lookup{x}{\Env; \Pattern, \private{y} : \Var} &= \Lookup{x}{\Env \setminus \Var(\Env); \Pattern} & x \neq y\\
\Lookup{x}{\overrightarrow{\cdot}} &= \Fail\\
\Lookup{x}{\overrightarrow{\Public{y} : \Constant}, x : \Constant} &= (x : \Constant)\\
\Lookup{x}{\overrightarrow{\Public{x} : \Constant}, y : \Constant} &= \Lookup{x}{\overrightarrow{\Public{x} : \Constant}} & x \neq y
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Scope} &= \Lookup{x_1.x_2.\cdots.x_n}{\Env} & x_1 \notin \Domain(\Scope)\\
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Scope} &= \Fail & x_1 \in \Domain(\Scope)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Module, x_1 : \mathsf{Module}\left(\overrightarrow{\Public{x}:\Constant}\right)} &= \Lookup{x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}}\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\cdot}} &= \Fail\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}, y : \Constant} &= \Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}} & x_1 \neq y\\
\Lookup{x_1.x_2.\cdots.x_n}{\overrightarrow{\Public{y}:\Constant}, x_1: \mathsf{Module}\left(\overrightarrow{\Public{x}:\Constant}\right)} &= \Lookup{x_2.\cdots.x_n}{\overrightarrow{\Public{x}:\Constant}}
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Pattern} &= \Lookup{x_1.x_2.\cdots.x_n}{\Env} & x_1 \notin \Domain(\Pattern)\\
\Lookup{x_1.x_2.\cdots.x_n}{\Env; \Pattern} &= \Fail & x_1 \in \Domain(\Scope)
\end{aligned}
\end{equation*}
\begin{equation*}
\begin{aligned}
\Psi(\cdot) &= ()\\
\Psi(\Env; \cdot_\Scope) &= \Psi(\Env)\\
\Psi(\Env; \Scope, x : \mathsf{LF}_{\mathsf{term}}) &= \Psi(\Env; \Scope) \oplus (x : \mathsf{LF}_{\mathsf{term}})\\
\Psi(\Env; \Scope, x : \Var) &= \Psi(\Env; \Scope) & \Var \neq \mathsf{LF}_{\mathsf{term}}\\
\Psi(\Env; \cdot_\Module) &= \Psi(\Env)\\
\Psi(\Env; \Module) &= \Psi(\Env)\\
\Psi(\Env; \cdot_\Pattern) &= ()\\
\Psi(\Env; \Pattern, \private{x} : \mathsf{LF}_{\mathsf{term}}) &= \Psi(\Pattern) \oplus (x : \mathsf{LF}_{\mathsf{term}})\\
\Psi(\Env; \Pattern, \private{x} : \Var) &= \Psi(\Pattern) & \Var \neq \mathsf{LF}_{\mathsf{term}}
\end{aligned}
\end{equation*}

\subsection{Implementing Unified Indexing}

In the implementation, a referencing environment is a stack of scopes.
Each scope holds a tree of bindings, where each node is a stack of entries.
Concretely, this tree is supported by dictionaries associating identifiers to stacks of entries, each of which may optionally point to a subtree of bindings.
A lookup for the definition bound to a fully qualified identifier in a referencing environment searches for the topmost scope whose tree of bindings contains the leading identifier in the fully qualified identifier.
Once that scope is found, then its tree of bindings is traversed following the list of identifiers that forms the fully qualified identifier.
The topmost entry in the stack associated with the trailing identifier is the one that's returned.
If the traversal of the stack of scopes fails or if no node in the tree of bindings can be found to match the fully qualified identifier, then the lookup fails.
The stack structures at the level of scopes and entries allows for identifier shadowing.
On the other hand, the dictionaries speed up identifier lookups.

\begin{figure}[htb]
\includegraphics[width=\textwidth]{figures/referencing-environment-implementation.eps}
\caption[Example referencing environment in the implementation]{%
Diagram of the referencing environment at hole \texttt{\verbhole{?h3}} from figure~\ref{figure:referencing-environment-example} as it is implemented in \Beluga~\texttt{v1.1}.
The identifiers on the left are part of the global scope, and are each associated with a stack of bindings to support shadowing.
The numbering \texttt{\#1}, \texttt{\#2}, ..., \texttt{\#7} denotes the symbolic identifiers from the signature reconstruction store that are associated with the constants.
The aliases introduced by opening module \texttt{Nat} are properly handled, such that constant \texttt{\#3} can be referenced either as \texttt{Nat.z} or \texttt{z}.
}
\end{figure}

% TODO: Illustrate this structure

% TODO: Present the data structures for name resolution in the implementation (binding tree, binding domains, scope stack, context sizes for de Bruijn indices computations)

\section{Discussion}

% TODO: Purpot that we can have a unification algorithm in a named setting if we compute de Bruijn indices on the fly

% TODO: Purpot that this implementation is scalable to multi-modal logics and multi-level contextual modal logic

Given \Beluga's design for signature-level declaration of constants, the indexing phase can be parallelized.
This is because the body of a signature-level declaration is guaranteed not to export non-constant identifiers, which means that most of the \ac{AST} can be disregarded when we need to construct the referencing environment right before a signature-level declaration.
As such, the declarations in a signature can first be traversed to preallocate symbolic identifiers for toplevel constants and store them in a queue.
Concurrent threads can then be assigned non-overlapping ranges of declarations to process, and the initial referencing environment for each can be constructed using only that queue.
