\chapter{State Management for Incremental Proof Development}

% TODO:

\section{Signature Reconstruction Pipeline}

% TODO: Provide a more fine-grained presentation of \Beluga's semantic analysis phase, with an emphasis on explicit state management and ACID transactions

\section{Indexing}\label{section:indexing}

% TODO:

% TODO: Present the data structures for name resolution in the implementation (binding tree, binding domains, scope stack, context sizes for de Bruijn indices computations)

% TODO: Purpot that we can have a unification algorithm in a named setting if we compute de Bruijn indices on the fly

% TODO: Prupot that this implementation is scalable to multi-modal logics and multi-level contextual modal logic

% TODO: Present a model for mechanizing name resolution semantic analysis, using an association list, context sizes and binding sorts (bindings tagged with their domains)

\begin{figure}
\centering
\begin{tabular}{lrcl}
Referencing environment & $\Xi$ & $\Coloneqq$ & $\cdot \mid \Xi; \mathbb{S} \mid \Xi; \mathbb{M} \mid \Xi; \mathbb{P}$\\
Plain scope & $\mathbb{S}$ & $\Coloneqq$ & $\cdot \mid \mathbb{S}, x : \mathbb{V}$\\
Module scope & $\mathbb{M}$ & $\Coloneqq$ & $\cdot \mid \mathbb{M}, x_\Downarrow : \mathbb{C} \mid \mathbb{M}, x_\Uparrow : \mathbb{C}$\\
Pattern scope & $\mathbb{P}$ & $\Coloneqq$ & $\cdot \mid \mathbb{P}, x_\downarrow : \mathbb{V} \mid \mathbb{P}, x_\uparrow : \mathbb{V}$\\
Entry & $\mathbb{E}$ & $\Coloneqq$ & $ \mathbb{C} \mid \mathbb{V} $\\
Constant & $ \mathbb{C} $ & $ \Coloneqq $ & $\mathsf{LF}_{\mathsf{type\ const}} \mid \mathsf{LF}_{\mathsf{term\ const}} \mid \mathsf{Module}\left(\overrightarrow{x_\Uparrow : \mathbb{C}}\right) \mid \cdots$\\
Variable & $ \mathbb{V} $ & $ \Coloneqq $ & $ \mathsf{LF}_{\mathsf{term}} \mid \mathsf{Comp}_{\mathsf{term}} \mid \mathsf{Subst} \mid \mathsf{Ctx} \mid \mathsf{Param} $
\end{tabular}
\caption[Definition of the structure of referencing environments for indexing \Beluga signatures.]{%
Definition of the structure of referencing environments for indexing \Beluga signatures.
Some variants for constant entries have been omitted for brevity.
Identifiers denoted as $x_\Downarrow$ and $x_\Uparrow$ in a module scope denote private declarations and public declarations respectively.
Likewise, identifiers denoted as $x_\downarrow$ and $x_\uparrow$ in a pattern scope denote inner-pattern variables and pattern variables respectively.
}
\end{figure}

\begin{equation}
\infer{x : \mathbb{V} \in \mathbb{S}, x : \mathbb{V}}{}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \mathbb{S}, y : \mathbb{E}'}{x : \mathbb{V} \in \mathbb{S} & x \neq y}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \mathbb{M}, x_\Downarrow : \mathbb{C}}{}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \mathbb{M}, x_\Uparrow : \mathbb{C}}{}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \mathbb{M}, y_\Downarrow : \mathbb{C}'}{x : \mathbb{C} \in \mathbb{M} & x \neq y}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \mathbb{M}, y_\Uparrow : \mathbb{C}'}{x : \mathbb{C} \in \mathbb{M} & x \neq y}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \mathbb{P}, x_\downarrow : \mathbb{V}}{}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \mathbb{P}, y_\downarrow : \mathbb{V}}{x : \mathbb{V} \in \mathbb{P} & x \neq y}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \mathbb{P}, y_\uparrow : \mathbb{V}}{x : \mathbb{V} \in \mathbb{P} & x \neq y}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \Xi; \mathbb{S}}{x : \mathbb{V} \in \mathbb{S}}
\end{equation}

\begin{equation}
\infer{x : \mathbb{E} \in \Xi; \mathbb{S}}{x \notin \mathbb{S} & x : \mathbb{E} \in \Xi}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \Xi; \mathbb{M}}{x : \mathbb{C} \in \mathbb{M}}
\end{equation}

\begin{equation}
\infer{x : \mathbb{E} \in \Xi; \mathbb{M}}{x \notin \mathbb{M} & x : \mathbb{E} \in \Xi}
\end{equation}

\begin{equation}
\infer{x : \mathbb{V} \in \Xi; \mathbb{P}}{x : \mathbb{V} \in \mathbb{P}}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \Xi; \mathbb{P}}{x \notin \mathbb{P} & x : \mathbb{C} \in \Xi}
\end{equation}

\begin{equation}
\infer{x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi; \mathbb{S}}{x_1 \notin \mathbb{S} & x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi}
\end{equation}

\begin{equation}
\infer{x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi; \mathbb{M}}{x_1 \notin \mathbb{M} & x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi}
\end{equation}

\begin{equation}
\infer{x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi; \mathbb{P}}{x_1 \notin \mathbb{P} & x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \left(\overrightarrow{x_\Uparrow' : \mathbb{C}'}, x_\Uparrow : \mathbb{C}\right)}{}
\end{equation}

\begin{equation}
\infer{x : \mathbb{C} \in \left(\overrightarrow{x_\Uparrow' : \mathbb{C}'}, y_\Uparrow : \mathbb{C}\right)}{x : \mathbb{C} \in \overrightarrow{x_\Uparrow' : \mathbb{C}'} & x \neq y}
\end{equation}

\begin{equation}
\infer{x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \overrightarrow{x_\Uparrow : \mathbb{C}'}}{x_1 : \mathsf{Module}\left(\overrightarrow{x_\Uparrow' : \mathbb{C}''}\right) \in \overrightarrow{x_\Uparrow : \mathbb{C}'} & x_2 . \cdots . x_n : \mathbb{C} \in \overrightarrow{x_\Uparrow' : \mathbb{C}''}}
\end{equation}

\begin{equation}
\infer{x_1 . x_2 . \cdots . x_n : \mathbb{C} \in \Xi; \mathbb{M}, x_1 : \mathsf{Module}\left(\overrightarrow{x_\Uparrow : \mathbb{C}'}\right)}{x_2 . \cdots . x_n : \mathbb{C} \in \overrightarrow{x_\Uparrow : \mathbb{C}'}}
\end{equation}

\section{Pretty-Printing}

% What is pretty-printing?

Pretty-printing is the process that transforms an \ac{AST} back into its textual representation.
This feature of programming languages is often used to implement automated formatting software as part of tooling.
As it pertains to \Beluga and \Harpoon, pretty-printing is used by the developers during debugging to trace the execution of signature reconstruction, and it is used by the user when programmatically generated programs need to be displayed in interactive sessions.

% What are considerations to make when it comes to implementing pretty-printing?

Depending on the lexical conventions used during parsing, a pretty-printed \ac{AST} may not exactly correspond to its initial textual representation.
Indeed, the program's layout may change, inline comments may be printed in different locations, and extraneous parentheses may be removed.

Handling of the printed program's layout can be implemented using the algorithm described in~\cite{oppen1980prettyprinting}, whereby layout boxes and break hints are output during printing, and then actual break point locations are later computed to satisfy the layout and margin constraints.
The \OCaml standard library provides an implementation of this algorithm in its \mintinline{ocaml}|Format| module~\cite{leroy2022ocaml}.

The usual lexical convention is to treat comments as white spaces.
This simplifies the \ac{AST} representation of programs by effectively discarding all the comments.
However, during pretty-printing for formatting a program, those comments need to be restored.
A separate interval map data structure may be created during the lexing stage in order to keep track of inline comments with respect to their location.
Provided the program \ac{AST} is annotated with locations, then it is possible during printing to determine where a comment should be spliced in.

Handling of parentheses is less straightforward.
Indeed, a node in the program's \ac{AST} needs to be mapped back to the parser production that created it in order to determine its precedence.
Additionally, the associativity of operators appearing at the same precedence level must be taken into consideration to avoid producing ambiguous textual representations.

% How can pretty-printing be implemented in Beluga?

Pretty-printing of \Beluga's internal syntax requires the generation of fresh identifiers to replace de Bruijn indices.
Hence, not only is printing stateful, it also needs an auxiliary data structure containing the set of identifiers that are used by sub-expressions.
Indeed, one needs to know what identifiers are used in the term under a $\lambda$-abstraction before generating an identifier for the $\lambda$-abstraction's parameter.
Otherwise, the generated identifier may shadow a referenced identifier.
The data structure to support this feature may be implemented in many ways, but in general this problem reduces to annotating a tree with additional data~\cite{najd2016trees}:

\begin{enumerate}
\item
Parallel data types equipped with extra fields may be defined for each kind of node in the \ac{AST}.
During pretty-printing, the \ac{AST} and this auxiliary data structure then must be traversed at the same time.
\item
Each node in the \ac{AST} may be equipped with a unique identifier to be used as key in a map data structure.
Then, lookups can be made on that map during printing to fetch the necessary data.
\item
The auxiliary data may be embedded type-safely into the \ac{AST} using recursion schemes.
\end{enumerate}

The approach with the least impact on the rest of the implementation is to construct printing closures using a top-down traversal of the \ac{AST}.
At any given node, this traversal recursively computes the set of used de Bruijn offsets, and then constructs a closure accepting the referencing environment to determine the identifiers corresponding to those offsets.

% TODO:

\section{Testing}

% TODO: Present data-driven testing
% TODO: Present the micro-tests and benefits of having an unambiguous AST to inspect
% TODO: Present the parser test using pretty-printing

\section{Related Work}
