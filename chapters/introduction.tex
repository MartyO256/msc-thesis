\chapter{Introduction}

% TODO: Citations

% TODO(Antoine): You answer a lot of "what" questions.  For an introduction, the "why" questions are maybe more important.  "Why mechanized meta-theory?"  "Why dependent types?"  "Why structural editing?"  As a reader, I don't know what problems are solved with these tools.

% What is mechanized meta-theory?

% What are dependently-typed programming languages?

% What is Beluga? What is HOAS? What is contextual modal type theory?
\Beluga~\cite{pientka2010beluga} is a dependently-typed programming language for specifying and proving properties about formal systems using contextual modal type theory~\cite{nanevski2008contextual}.
It leverages the \acf{LF}~\cite{harper1993framework}, extended with explicit contexts, contextual objects and substitutions~\cite{DBLP:journals/corr/abs-1009-2789, cave2013first}, which allow for logic reasoning involving open terms.
Using \ac{HOAS}~\cite{pfenning1988higher}, elegant and succinct definitions can be made in \LF to subsequently prove theorems pertaining to programming languages and $ \lambda $-calculi, such as type safety for System F, cut-admissibility in the intuitionistic sequent calculus, or termination of weak-head normalization for the simply-typed lambda calculus.

% How does one specify a formal system using Beluga?

% What are interactive theorem provers?
Interactive theorem proving is the computer-assisted process of finding valid proofs for propositions in a logic system.
Proof assistants have been implemented and successfully leveraged to prove fundamentals of mathematics and type theories.
\Agda~\cite{clffolp}, \Coq~\cite{Coq, bertot2013interactive}, \textsc{Isabelle}~\cite{nipkow2002isabelle} and \textsc{Lean}~\cite{lean4} are among the most prevalent proof assistants used in the formalization of programming languages.

% What is Harpoon?
\Harpoon~\cite{errington2021harpoon} is an interactive frontend to \Beluga for proving theorems interactively.
Its design is largely inspired by \Coq's interactive proof mode using tactics to solve unproven goals.

% What is structured editing?
Structural (or projectional) editing in programming language tooling is the functionality of a software editor that allows the user to manipulate \acp{AST} directly.
This is in contrast with plain text editors in which users may only edit textual representations of their programs, that then require parsing to be interpreted.
The \textsc{Hazel}~\cite{omar2017hazelnut, omar2019live} functional programming environment is a notable example of a structural editor in the functional programming community for its ability to dynamically provide useful information as the user writes programs with holes.

% What are typical edit actions in programming languages?
Structural editors define a set of edit actions the user may execute at any given point in their editing session.
Typical edit actions include navigating the \ac{AST} being modified, as well as constructing new nodes using either a graphical interface or a textual language.
These actions are then reflected in the editor state.

% What are edit actions required by Beluga and Harpoon?
Although \Beluga's interactive mode and \Harpoon are \acp{REPL} as opposed to structural editors, they do share functional requirements.
Indeed, as in \textsc{Hazel}, users of \Beluga and \Harpoon postpone the completion of programs or proof scripts by inserting holes in them.
These holes are later filled in with the help of a proof assistant that provides typing information for the identifiers in scope for each hole.
As such, both \acp{REPL} and structural editors are required to construct and update an editor state as the user performs edit actions.

% In general, what are challenges to implementing edit actions?
Edit actions in \Beluga and \Harpoon include navigating between holes in programs and proof scripts respectively, as well as displaying type information for constants, and performing case analyses on meta-level and computation-level objects identified by (meta-)variables.
These actions require surgical manipulation of the editor state to ensure soundness of the \ac{AST} being edited is preserved, as well as to prevent the undesirable propagation of information like typing constraints in unrelated edit locations.

% In Beluga and Harpoon specifically, what are the challenges to implementing edit actions?
Historically, \Beluga was not implemented with the mindset of supporting the level of interactivity that \Harpoon purports to have.
Indeed, as is the case with prototype implementations of programming languages, \Beluga's early development focused on implementing a type-checker for its type theory and a parser for its concrete syntax.
The software architectural pattern that arose from this implementation was the pipeline pattern, in which the data processing of programs from its textual to its \ac{AST} representation is handled in single-responsibility phases that sequentially augment and refine the data for later use.
Specifically with respect to \Beluga, these phases have evolved to include implicit argument reconstruction, the translation from a named to a nameless representation of binders using de Bruijn indices, normalization, type-checking, and totality-checking.
What transpires from this design is a unilateral flow of information from the concrete syntax to the internal representation of programs in \Beluga.
Early optimizations were put in place to maximize the performance of this processing pipeline.
In particular, a single global representation of the \Beluga program being processed was implemented to provide information to later processing phases in a feedforward fashion.
This simplified the implementation of new features since globally accessible data does not need dependency injection.
This design was sound only under the assumption that the information in the application would flow in only one direction.
Unfortunately, the introduction of \Beluga's interactive mode and subsequently \Harpoon inadvertently broke that assumption.
Indeed, soundness issues have arose with regards to features and processes of the two system that require inspecting only a subset of a signature and its referencing environment.
This issue of locality further has further been shown to deteriorate the performance of the logic programming engine used to automate proof search.

% What is the proposed approach to supporting edit actions in Beluga and Harpoon?
This thesis reports on improvements made to the implementation \Beluga and \Harpoon to address some of the soundness issues in interactive proof development in these two systems.
In particular, we present an explicitly stateful algorithm for the parsing, disambiguation and indexing of \Beluga programs to ensure correct name resolutions across editing states.
This fixed the soundness issue for \Harpoon proof sessions whereby constants declared after the proof hole would be in scope and shadow earlier declarations.
The revised approach to name resolution allowed for consistent namespacing of constants to be implemented.
Additionally, the \Beluga feature of fixity pragmas for defining prefix, infix or postfix notations for \LF-level constants was expanded upon to also work with computation-level constants.
Using the proposed specification for \Beluga and \Harpoon's grammars, the generation of \textsc{HTML} pages corresponding to signatures was restored, with a new and improved pretty-printing algorithm of the concrete syntax.
Overall, the changes have improved the maintainability, resiliency and stability of the affected modules, and have proposed better architectural design patterns that may be applied to the rest of the implementation.

% TODO:


% TODO:

%\section{\Beluga and \Harpoon}

% TODO: To justify the addition of modules (functioning only as namespaces), use an example of translation between two languages (deBruijn vs. HOAS for instance)
% TODO: To justify the dynamic side of things, consider a query appearing in the middle of a signature. The logic engine is considering too large of a search space by including the constants appearing later in the signature.
% TODO: To additionally justify the dynamic side of things, talk about structured proof editing in a dynamic environment like Harpoon, or Beluga's interactive mode.

% TODO: Drop Harpoon, focus on tension between static and dynamic settings
% TODO: Add the Beluga language specification as an appendix

% What are dependent types? What is LF? What is Twelf? What proofs have been successfully mechanized in Twelf?

% What is contextual modal type theory? Why do we want contextual modal type theory?

% What is Beluga? What proofs have been successfully mechanized in Beluga?

% What is Harpoon? What proofs have been successfully mechanized in Harpoon?

% TODO:

%\section{Structured Editing}

% TODO:
