@article{omar2017hazelnut,
  title = {{Hazelnut: A Bidirectionally Typed Structure Editor Calculus}},
  author = {Omar, Cyrus and Voysey, Ian and Hilton, Michael and Aldrich, Jonathan and Hammer, Matthew A},
  journal = {ACM SIGPLAN Notices},
  volume = {52},
  number = {1},
  pages = {86--99},
  year = {2017},
  publisher = {ACM New York, NY, USA}
}

@article{omar2019live,
  title = {{Live Functional Programming with Typed Holes}},
  author = {Omar, Cyrus and Voysey, Ian and Chugh, Ravi and Hammer, Matthew A},
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {3},
  number = {POPL},
  pages = {1--32},
  year = {2019},
  publisher = {ACM New York, NY, USA}
}

@book{aho2007compilers,
  title = {{Compilers: Principles, Techniques, and Tools}},
  author = {Aho, Alfred V. and Sethi, Ravi and Ullman, Jeffrey D.},
  volume = {2},
  year = {2007},
  publisher = {Addison-wesley Reading}
}

@article{ferreira2012compiler,
  title = {A Compiler for the dependently typed language Beluga},
  author = {Ferreira Ruiz, Francisco},
  year = {2012}
}

@article{germain2010implementation,
  title = {Implementation of a dependently typed functional programming language},
  author = {Germain, Renaud},
  year = {2010},
  publisher = {McGill University}
}

@article{harper1993framework,
  title = {A framework for defining logics},
  author = {Harper, Robert and Honsell, Furio and Plotkin, Gordon},
  journal = {Journal of the ACM (JACM)},
  volume = {40},
  number = {1},
  pages = {143--184},
  year = {1993},
  publisher = {ACM New York, NY, USA}
}

@article{pientka2013insider,
  title = {An insider's look at {LF} type reconstruction: everything you (n)ever wanted to know},
  author = {Pientka, Brigitte},
  journal = {Journal of Functional Programming},
  volume = {23},
  number = {1},
  pages = {1--37},
  year = {2013},
  publisher = {Cambridge University Press}
}

@article{thibodeau2021intensional,
  title = {An intensional type theory of coinduction with copatterns},
  author = {Thibodeau, David},
  year = {2021}
}

@inproceedings{ferreira2014bidirectional,
  title = {Bidirectional elaboration of dependently typed programs},
  author = {Ferreira, Francisco and Pientka, Brigitte},
  booktitle = {Proceedings of the 16th International Symposium on Principles and Practice of Declarative Programming},
  pages = {161--174},
  year = {2014}
}

@inproceedings{ferreira2013compiling,
  title = {Compiling contextual objects: bringing higher-order abstract syntax to programmers},
  author = {Ferreira, Francisco and Monnier, Stefan and Pientka, Brigitte},
  booktitle = {Proceedings of the 7th workshop on Programming languages meets program verification},
  pages = {13--24},
  year = {2013}
}

@article{abel2013copatterns,
  title = {Copatterns: Programming infinite structures by observations},
  author = {Abel, Andreas and Pientka, Brigitte and Thibodeau, David and Setzer, Anton},
  journal = {ACM SIGPLAN Notices},
  volume = {48},
  number = {1},
  pages = {27--38},
  year = {2013},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{DBLP:journals/corr/abs-1009-2789,
  author = {Andreas Abel and Brigitte Pientka},
  editor = {Karl Crary and Marino Miculan},
  title = {{Explicit Substitutions for Contextual Type Theory}},
  booktitle = {Proceedings 5th International Workshop on Logical Frameworks and Meta-languages: Theory and Practice, {LFMTP} 2010, Edinburgh, UK, 14th July 2010},
  series = {{EPTCS}},
  volume = {34},
  pages = {5--20},
  year = {2010},
  url = {https://doi.org/10.4204/EPTCS.34.3},
  doi = {10.4204/EPTCS.34.3},
  timestamp = {Wed, 12 Sep 2018 01:05:14 +0200},
  biburl = {https://dblp.org/rec/journals/corr/abs-1009-2789.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@inproceedings{cave2013first,
  title = {First-class substitutions in contextual type theory},
  author = {Cave, Andrew and Pientka, Brigitte},
  booktitle = {Proceedings of the Eighth ACM SIGPLAN international workshop on Logical frameworks \& meta-languages: theory \& practice},
  pages = {15--24},
  year = {2013}
}

@inproceedings{frost2008parser,
  title = {Parser combinators for ambiguous left-recursive grammars},
  author = {Frost, Richard A and Hafiz, Rahmatullah and Callaghan, Paul},
  booktitle = {Practical Aspects of Declarative Languages: 10th International Symposium, PADL 2008, San Francisco, CA, USA, January 7-8, 2008. Proceedings 10},
  pages = {167--181},
  year = {2008},
  organization = {Springer}
}

@inproceedings{danielsson2008parsing,
  title = {{Parsing Mixfix Operators}},
  author = {Danielsson, Nils Anders and Norell, Ulf},
  booktitle = {IFL},
  pages = {80--99},
  year = {2008},
  organization = {Springer}
}

@article{dijkstra1961algol,
  title = {{Algol 60 translation: An Algol 60 translator for the X1 and Making a translator for Algol 60}},
  author = {Dijkstra, Edsger Wybe},
  journal = {Stichting Mathematisch Centrum. Rekenafdeling},
  number = {MR 34/61},
  year = {1961},
  publisher = {Stichting Mathematisch Centrum}
}

@article{afroozeh2019practical,
  title = {Practical general top-down parsers},
  author = {Afroozeh, Ali and Izmaylova, Anastasia},
  year = {2019}
}

@article{ferreira2018proofs,
  title = {Proofs and programs about open terms},
  author = {Ferreira Ruiz, Francisco},
  year = {2018}
}

@inproceedings{jim2010semantics,
  title = {Semantics and algorithms for data-dependent grammars},
  author = {Jim, Trevor and Mandelbaum, Yitzhak and Walker, David},
  booktitle = {Proceedings of the 37th annual ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages = {417--430},
  year = {2010}
}

@article{mens2004survey,
  title = {A survey of software refactoring},
  author = {Mens, Tom and Tourw{\'e}, Tom},
  journal = {IEEE Transactions on software engineering},
  volume = {30},
  number = {2},
  pages = {126--139},
  year = {2004},
  publisher = {IEEE}
}

@article{teitelbaum1981cornell,
  title = {The {Cornell} program synthesizer: a syntax-directed programming environment},
  author = {Teitelbaum, Tim and Reps, Thomas},
  journal = {Communications of the ACM},
  volume = {24},
  number = {9},
  pages = {563--573},
  year = {1981},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{pientka2010beluga,
  title = {Beluga: A framework for programming and reasoning with deductive systems (system description)},
  author = {Pientka, Brigitte and Dunfield, Jana},
  booktitle = {Automated Reasoning: 5th International Joint Conference, IJCAR 2010, Edinburgh, UK, July 16-19, 2010. Proceedings 5},
  pages = {15--21},
  year = {2010},
  organization = {Springer}
}

@article{nanevski2008contextual,
  title = {{Contextual Modal Type Theory}},
  author = {Nanevski, Aleksandar and Pfenning, Frank and Pientka, Brigitte},
  journal = {ACM Transactions on Computational Logic (TOCL)},
  volume = {9},
  number = {3},
  pages = {1--49},
  year = {2008},
  publisher = {ACM New York, NY, USA}
}

@InProceedings{clffolp,
  author = {Abel, Andreas and Coquand, Thierry and Norell, Ulf},
  editor = {Gramlich, Bernhard},
  title = {{Connecting a Logical Framework to a First-Order Logic Prover}},
  booktitle = {Frontiers of Combining Systems},
  year = {2005},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  pages = {285--301},
  isbn = {978-3-540-31730-2}
}

@Manual{Coq,
  title = {The Coq proof assistant reference manual},
  author = {The Coq development team},
  organization = {LogiCal Project},
  note = {Version 8.0},
  year = {2004},
  url = {http://coq.inria.fr}
}

@book{bertot2013interactive,
  title = {Interactive theorem proving and program development: Coq’Art: the calculus of inductive constructions},
  author = {Bertot, Yves and Cast{\'e}ran, Pierre},
  year = {2013},
  publisher = {Springer Science \& Business Media}
}

@inproceedings{errington2021harpoon,
  title = {Harpoon: Mechanizing Metatheory Interactively: (System Description)},
  author = {Errington, Jacob and Jang, Junyoung and Pientka, Brigitte},
  booktitle = {Automated Deduction--CADE 28: 28th International Conference on Automated Deduction, Virtual Event, July 12--15, 2021, Proceedings 28},
  pages = {636--648},
  year = {2021},
  organization = {Springer}
}

@book{nipkow2002isabelle,
  title = {Isabelle/HOL: a proof assistant for higher-order logic},
  author = {Nipkow, Tobias and Paulson, Lawrence C. and Wenzel, Markus},
  volume = {2283},
  year = {2002},
  publisher = {Springer Science \& Business Media}
}

@misc{wenzel2023isabelleimpl,
  title = {The {Isabelle/Isar} Implementation},
  author = {Wenzel, Makarius and Berghofer, Stefan and Haftmann, Florian and Paulson, Larry},
  year = {2023}
}

@misc{wenzel2023isabelleisarref,
  title = {The {Isabelle/Isar} Reference Manual},
  author = {Wenzel, Makarius and Ballarin, Clemens and Berghofer, Stefan and Blanchette, Jasmin and Bourke, Timothy and Bulwahn, Lukas and  Chaieb, Amine and Dixon, Lucas and Haftmann, Florian and Huffman, Brian and Hupel, Lars and Klein, Gerwin and Krauss, Alexander and Kunčar, Ondřej and Lochbihler, Andreas and Nipkow, Tobias and Noschinski, Lars and von Oheimb, David and Paulson, Larry and Skalberg, Sebastian and Sternagel, Christian and Traytel, Dmitriy},
  year = {2023}
}

@misc{wenzel2023isabellesys,
  title = {The {Isabelle} System Manual},
  author = {Wenzel, Makarius},
  year = {2023}
}

@inproceedings{ballarin2006interpretation,
  title = {{Interpretation of locales in Isabelle: Theories and proof contexts}},
  author = {Ballarin, Clemens},
  booktitle = {Mathematical Knowledge Management: 5th International Conference, MKM 2006, Wokingham, UK, August 11-12, 2006. Proceedings 5},
  pages = {31--43},
  year = {2006},
  organization = {Springer}
}

@InProceedings{lean4,
  author = {Moura, Leonardo de and Ullrich, Sebastian},
  editor = {Platzer, Andr{\'e} and Sutcliffe, Geoff},
  title = {The Lean 4 Theorem Prover and Programming Language},
  booktitle = {Automated Deduction -- CADE 28},
  year = {2021},
  publisher = {Springer International Publishing},
  address = {Cham},
  pages = {625--635},
  isbn = {978-3-030-79876-5}
}

@misc{hutton1996monadic,
  title = {Monadic parser combinators},
  author = {Hutton, Graham and Meijer, Erik},
  year = {1996}
}

@inproceedings{generalparsercombs,
  author = {Izmaylova, Anastasia and Afroozeh, Ali and Storm, Tijs van der},
  title = {Practical, General Parser Combinators},
  year = {2016},
  isbn = {9781450340977},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/2847538.2847539},
  doi = {10.1145/2847538.2847539},
  booktitle = {Proceedings of the 2016 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation},
  pages = {1–12},
  numpages = {12},
  keywords = {higher-order functions, general parsing, left recursion, memoization, Parser combinators, continuation-passing style},
  location = {St. Petersburg, FL, USA},
  series = {PEPM '16}
}

@article{leijen2001parsec,
  title = {Parsec: Direct style monadic parser combinators for the real world},
  author = {Leijen, Daan and Meijer, Erik},
  year = {2001}
}

@book{Burge1975-BURRPT,
  year = {1975},
  author = {William H. Burge},
  publisher = {Addison-Wesley},
  title = {Recursive Programming Techniques}
}

@article{oppen1980prettyprinting,
  title = {Prettyprinting},
  author = {Oppen, Dereck C},
  journal = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume = {2},
  number = {4},
  pages = {465--483},
  year = {1980},
  publisher = {ACM New York, NY, USA}
}

@misc{leroy2022ocaml,
  title = {The OCaml system release 5.0: Documentation and user's manual},
  author = {Leroy, Xavier and Doligez, Damien and Frisch, Alain and Garrigue, Jacques and R{\'e}my, Didier and Vouillon, J{\'e}r{\^o}me},
  year = {2022},
  school = {Inria}
}

@article{de2003camlp4,
  title = {Camlp4 reference manual},
  author = {de Rauglaudre, Daniel},
  journal = {Online (September 2003)},
  year = {2003}
}

@article{pfenning1988higher,
  title = {Higher-order abstract syntax},
  author = {Pfenning, Frank and Elliott, Conal},
  journal = {ACM sigplan notices},
  volume = {23},
  number = {7},
  pages = {199--208},
  year = {1988},
  publisher = {ACM New York, NY, USA}
}

@article{chomsky1956three,
  title = {Three models for the description of language},
  author = {Chomsky, Noam},
  journal = {IRE Transactions on information theory},
  volume = {2},
  number = {3},
  pages = {113--124},
  year = {1956},
  publisher = {IEEE}
}

@article{unambiguousprec,
  title = {Characterizing unambiguous precedence systems in expressions without superfluous parentheses},
  author = {Wafik Boulos Lotfallah},
  journal = {International Journal of Computer Mathematics},
  volume = {86},
  number = {1},
  pages = {1-20},
  year  = {2009},
  publisher = {Taylor & Francis},
  doi = {10.1080/00207160802166499},
  URL = {https://doi.org/10.1080/00207160802166499},
  eprint = {https://doi.org/10.1080/00207160802166499}
}

@article{najd2016trees,
  title = {Trees that grow},
  author = {Najd, Shayan and Jones, Simon Peyton},
  journal = {arXiv preprint arXiv:1610.04799},
  year = {2016}
}

@Inbook{barendregt2003,
  author = {Barendregt, Henk},
  editor = {Kamareddine, Fairouz D.},
  title = {Towards an Interactive Mathematical Proof Mode},
  bookTitle = {Thirty Five Years of Automating Mathematics},
  year = {2003},
  publisher = {Springer Netherlands},
  address = {Dordrecht},
  pages = {25--36},
  abstract = {Formalizing mathematical proofs has as aim to represent arbitrary mathematical notions and proofs on a computer in order to construct a database of certified results useful to learn and develop the subject. At present it is mathematically not appealing to construct formal proofs. To make formalzing more mathematician-friendly one should have a good interface for proofs, definitions and computations. The proof-assistant Mizar does have a good interface for proofs, but not for making computations. Other assistants, like Coq based on type theory, do have a good interface for computations, but not for proofs. This paper sketches ways in which proofs are represented in a mathematical way. Although the underlying formalized statements come from the system Coq, this is not essential Mainly the paper has as aim to convince implementers of mathematical assistants to make systems in such a way that formalizing proofs becomes natural. Much further developed is the work on Isar providing a mathematical proof language for the assistant Isabelle. The approach in this paper is to approximate a proof language by writing proof-sketches, a notion by Wiedijk, with the aim that they should eventually be verifiable by a proof-checker. [Nederpelt, 2002] has a different approach: there the emphasis is on the ease of providing formalizations of mathematical definitions.},
  isbn = {978-94-017-0253-9},
  doi = {10.1007/978-94-017-0253-9_2},
  url = {https://doi.org/10.1007/978-94-017-0253-9_2}
}

@article{kaiser2018,
  author = {Kaiser, Jan-Oliver and Ziliani, Beta and Krebbers, Robbert and R\'{e}gis-Gianas, Yann and Dreyer, Derek},
  title = {Mtac2: Typed Tactics for Backward Reasoning in Coq},
  year = {2018},
  issue_date = {September 2018},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {2},
  number = {ICFP},
  url = {https://doi.org/10.1145/3236773},
  doi = {10.1145/3236773},
  abstract = {Coq supports a range of built-in tactics, which are engineered primarily to support backward reasoning. Starting from a desired goal, the Coq programmer can use these tactics to manipulate the proof state interactively, applying axioms or lemmas to break the goal into subgoals until all subgoals have been solved. Additionally, it provides support for tactic programming via OCaml and Ltac, so that users can roll their own custom proof automation routines. Unfortunately, though, these tactic languages share a significant weakness. They do not offer the tactic programmer any static guarantees about the soundness of their custom tactics, making large tactic developments difficult to maintain. To address this limitation, Ziliani et al. previously proposed Mtac, a new typed approach to custom proof automation in Coq which provides the static guarantees that OCaml and Ltac are missing. However, despite its name, Mtac is really more of a metaprogramming language than it is a full-blown tactic language: it misses an essential feature of tactic programming, namely the ability to directly manipulate Coq’s proof state and perform backward reasoning on it. In this paper, we present Mtac2, a next-generation version of Mtac that combines its support for typed metaprogramming with additional support for the programming of backward-reasoning tactics in the style of Ltac. In so doing, Mtac2 introduces a novel feature in tactic programming languages—what we call typed backward reasoning. With this feature, Mtac2 is capable of statically ruling out several classes of errors that would otherwise remain undetected at tactic definition time. We demonstrate the utility of Mtac2’s typed tactics by porting several tactics from a large Coq development, the Iris Proof Mode, from Ltac to Mtac2.},
  journal = {Proc. ACM Program. Lang.},
  month = {jul},
  articleno = {78},
  numpages = {31},
  keywords = {Theorem Proving, Coq, Dependent Types, Metaprogramming, Tactic Languages}
}

@inproceedings{delahaye2000tactic,
  title = {A tactic language for the system {Coq}},
  author = {Delahaye, David},
  booktitle = {Logic for Programming and Automated Reasoning: 7th International Conference, LPAR 2000 Reunion Island, France, November 6--10, 2000 Proceedings 7},
  pages = {85--95},
  year = {2000},
  organization = {Springer}
}

@article{smith2007ocamllex,
  title = {{ocamllex} and {ocamlyacc}},
  author = {Smith, Joshua B.},
  journal = {Practical OCaml},
  pages = {193--211},
  year = {2007},
  publisher = {Springer}
}

@article{foundation2008pientka,
  author = {Pientka, Brigitte},
  title = {A Type-Theoretic Foundation for Programming with Higher-Order Abstract Syntax and First-Class Substitutions},
  year = {2008},
  issue_date = {January 2008},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {43},
  number = {1},
  issn = {0362-1340},
  url = {https://doi.org/10.1145/1328897.1328483},
  doi = {10.1145/1328897.1328483},
  abstract = {Higher-order abstract syntax (HOAS) is a simple, powerful technique for implementing object languages, since it directly supports common and tricky routines dealing with variables, such as capture-avoiding substitution and renaming. This is achieved by representing binders in the object-language via binders in the meta-language. However, enriching functional programming languages with direct support for HOAS has been a major challenge, because recursion over HOAS encodings requires one to traverse lambda-abstractions and necessitates programming with open objects.We present a novel type-theoretic foundation based on contextual modal types which allows us to recursively analyze open terms via higher-order pattern matching. By design, variables occurring in open terms can never escape their scope. Using several examples, we demonstrate that our framework provides a name-safe foundation to operations typically found in nominal systems. In contrast to nominal systems however, we also support capture-avoiding substitution operations and even provide first-class substitutions to the programmer. The main contribution of this paper is a syntax-directed bi-directional type system where we distinguish between the data language and the computation language together with the progress and preservation proof for our language.},
  journal = {SIGPLAN Not.},
  month = {jan},
  pages = {371–382},
  numpages = {12},
  keywords = {logical frameworks, type system}
}

@incollection{pientka2010programming,
  title = {Programming inductive proofs: A new approach based on contextual types},
  author = {Pientka, Brigitte},
  booktitle = {Verification, Induction, Termination Analysis: Festschrift for Christoph Walther on the Occasion of His 60th Birthday},
  pages = {1--16},
  year = {2010},
  publisher = {Springer}
}

@article{resolveAmbiguity,
  author = {Viktor Palmkvist and Elias Castegren and Philipp Haller and David Broman},
  title = {Resolvable Ambiguity},
  journal = {CoRR},
  volume = {abs/1911.05672},
  year = {2019},
  url = {http://arxiv.org/abs/1911.05672},
  eprinttype = {arXiv},
  eprint = {1911.05672},
  timestamp = {Mon, 02 Dec 2019 13:44:01 +0100},
  biburl = {https://dblp.org/rec/journals/corr/abs-1911-05672.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{baelde2014abella,
  title = {Abella: A system for reasoning about relational specifications},
  author = {Baelde, David and Chaudhuri, Kaustuv and Gacek, Andrew and Miller, Dale and Nadathur, Gopalan and Tiu, Alwen and Wang, Yuting},
  journal = {Journal of Formalized Reasoning},
  volume = {7},
  number = {2},
  pages = {1--89},
  year = {2014}
}

@article{DEBRUIJN1972381,
  title = {Lambda calculus notation with nameless dummies, a tool for automatic formula manipulation, with application to the Church-Rosser theorem},
  journal = {Indagationes Mathematicae (Proceedings)},
  volume = {75},
  number = {5},
  pages = {381-392},
  year = {1972},
  issn = {1385-7258},
  doi = {https://doi.org/10.1016/1385-7258(72)90034-0},
  url = {https://www.sciencedirect.com/science/article/pii/1385725872900340},
  author = {N.G {de Bruijn}},
  abstract = {In ordinary lambda calculus the occurrences of a bound variable are made recognizable by the use of one and the same (otherwise irrelevant) name at all occurrences. This convention is known to cause considerable trouble in cases of substitution. In the present paper a different notational system is developed, where occurrences of variables are indicated by integers giving the “distance” to the binding λ instead of a name attached to that λ. The system is claimed to be efficient for automatic formula manipulation as well as for metalingual discussion. As an example the most essential part of a proof of the Church-Rosser theorem is presented in this namefree calculus.}
}

@inproceedings{debruijnlevels1995,
  author = {Lescanne, Pierre and Rouyer-Degli, Jocelyne},
  year = {1995},
  month = {04},
  pages = {294-308},
  title = {Explicit Substitutions with de Bruijn's Levels},
  volume = {914},
  isbn = {978-3-540-59200-6},
  doi = {10.1007/3-540-59200-8_65}
}

@book{norell2007towards,
  title = {Towards a practical programming language based on dependent type theory},
  author = {Norell, Ulf},
  volume = {32},
  year = {2007},
  publisher = {Chalmers University of Technology}
}

@software{agda2023,
  author = {{Agda Team}},
  title = {Agda 2.6.4},
  year = {2023},
  note = {\url{https://wiki.portal.chalmers.se/agda/pmwiki.php}},
}

@InProceedings{creager_et_al:OASIcs.EVCS.2023.8,
  author = {Creager, Douglas A. and van Antwerpen, Hendrik},
  title = {{Stack Graphs: Name Resolution at Scale}},
  booktitle = {Eelco Visser Commemorative Symposium (EVCS 2023)},
  pages = {8:1--8:12},
  series = {Open Access Series in Informatics (OASIcs)},
  ISBN = {978-3-95977-267-9},
  ISSN = {2190-6807},
  year = {2023},
  volume = {109},
  editor = {L\"{a}mmel, Ralf and Mosses, Peter D. and Steimann, Friedrich},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  URL = {https://drops.dagstuhl.de/opus/volltexte/2023/17778},
  URN = {urn:nbn:de:0030-drops-177789},
  doi = {10.4230/OASIcs.EVCS.2023.8},
  annote = {Keywords: Scope graphs, name binding, code navigation}
}

@InProceedings{vanantwerpen_et_al:LIPIcs.ECOOP.2021.1,
  author = {van Antwerpen, Hendrik and Visser, Eelco},
  title = {{Scope States: Guarding Safety of Name Resolution in Parallel Type Checkers}},
  booktitle = {35th European Conference on Object-Oriented Programming (ECOOP 2021)},
  pages = {1:1--1:29},
  series = {Leibniz International Proceedings in Informatics (LIPIcs)},
  ISBN = {978-3-95977-190-0},
  ISSN = {1868-8969},
  year = {2021},
  volume = {194},
  editor = {M{\o}ller, Anders and Sridharan, Manu},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  address = {Dagstuhl, Germany},
  URL = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.ECOOP.2021.1},
  URN = {urn:nbn:de:0030-drops-140441},
  doi = {10.4230/LIPIcs.ECOOP.2021.1},
  annote = {Keywords: type checking, name resolution, parallel algorithms}
}

@InProceedings{nameresolution,
  author = {Neron, Pierre and Tolmach, Andrew  and Visser, Eelco and Wachsmuth, Guido},
  editor = {Vitek, Jan},
  title = {{A Theory of Name Resolution}},
  booktitle = {Programming Languages and Systems},
  year = {2015},
  publisher = {Springer Berlin Heidelberg},
  address = {Berlin, Heidelberg},
  pages = {205--231},
  abstract = {We describe a language-independent theory for name binding and resolution, suitable for programming languages with complex scoping rules including both lexical scoping and modules. We formulate name resolution as a two-stage problem. First a language-independent scope graph is constructed using language-specific rules from an abstract syntax tree. Then references in the scope graph are resolved to corresponding declarations using a language-independent resolution process. We introduce a resolution calculus as a concise, declarative, and languageindependent specification of name resolution. We develop a resolution algorithm that is sound and complete with respect to the calculus. Based on the resolution calculus we develop language-independent definitions of $\alpha$-equivalence and rename refactoring. We illustrate the approach using a small example language with modules. In addition, we show how our approach provides a model for a range of name binding patterns in existing languages.},
  isbn = {978-3-662-46669-8}
}
